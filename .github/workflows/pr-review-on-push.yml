name: PR Review Trigger on Push

on:
  push:
    branches-ignore:
      - main
      - master
  pull_request_target:
    types:
      - synchronize

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: pr-review-on-push-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

jobs:
  trigger-review-cycle:
    name: Trigger review bots after push
    runs-on: ubuntu-latest
    if: |
      github.actor != 'github-actions[bot]' &&
      github.actor != 'codex-bot[bot]' &&
      github.actor != 'coderabbitai[bot]'
    steps:
      - name: Wait for debounce window
        run: sleep 15

      - name: Locate open pull request for branch
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const [owner, repo] = [context.repo.owner, context.repo.repo];
            const isPullRequestEvent =
              context.eventName === 'pull_request_target';
            const branch = isPullRequestEvent
              ? context.payload.pull_request.head.ref
              : context.ref.replace('refs/heads/', '');
            const headOwner = isPullRequestEvent
              ? context.payload.pull_request.head.repo.owner.login
              : owner;
            const { data: pulls } = await github.rest.pulls.list({
              owner,
              repo,
              head: `${headOwner}:${branch}`,
              state: 'open'
            });

            if (pulls.length === 0) {
              core.info('No PR found for this branch. Skipping.');
              core.setOutput('should_run', 'false');
              return;
            }

            const pr = pulls[0];
            const sameRepoPullRequest =
              isPullRequestEvent &&
              pr.head?.repo?.full_name?.toLowerCase() ===
                `${owner}/${repo}`.toLowerCase();

            if (sameRepoPullRequest) {
              core.info(
                'Same-repo pull_request_target event handled by push workflow.'
              );
              core.setOutput('should_run', 'false');
              return;
            }
            const initialPush =
              context.eventName === 'push' &&
              context.payload.before ===
                '0000000000000000000000000000000000000000';

            if (initialPush) {
              core.info('Initial branch push detected. Skipping triggers.');
              core.setOutput('should_run', 'false');
              return;
            }

            if (
              isPullRequestEvent &&
              context.payload.action !== 'synchronize'
            ) {
              core.info('Non-synchronize pull_request event. Skipping.');
              core.setOutput('should_run', 'false');
              return;
            }

            const body = pr.body ?? '';
            const iterationMatch = body.match(
              /<!--\s*REVIEW_ITERATION:\s*(\d+)\s*-->/i
            );
            const iteration = iterationMatch
              ? Number.parseInt(iterationMatch[1], 10)
              : 0;

            if (Number.isNaN(iteration)) {
              core.warning('Iteration marker missing or invalid. Using 0.');
            }

            if (iteration >= 5) {
              core.info(`Iteration ${iteration} at limit. Skipping.`);
              core.setOutput('should_run', 'false');
              return;
            }

            core.setOutput('should_run', 'true');
            core.setOutput('pr_number', pr.number.toString());
            core.setOutput('pr_body', body);

      - name: Ensure labels exist and set review status
        if: steps.pr.outputs.should_run == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = Number.parseInt(
              '${{ steps.pr.outputs.pr_number }}',
              10
            );
            const labelDefinitions = [
              {
                name: 'under-review',
                color: '1d76db',
                description: 'Automated review cycle in progress'
              },
              {
                name: 'awaiting-fixes',
                color: 'fbca04',
                description: 'Waiting for Codex fixes after CodeRabbit review'
              },
              {
                name: 'max-iterations-reached',
                color: 'd93f0b',
                description: 'Automated review/fix cycle capped at five rounds'
              }
            ];

            for (const label of labelDefinitions) {
              try {
                await github.rest.issues.getLabel({
                  owner,
                  repo,
                  name: label.name
                });
              } catch (error) {
                if (error.status === 404) {
                  core.info(`Creating missing label: ${label.name}`);
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    ...label
                  });
                } else {
                  throw error;
                }
              }
            }

            try {
              await github.rest.issues.removeLabel({
                owner,
                repo,
                issue_number: prNumber,
                name: 'awaiting-fixes'
              });
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
            }

            try {
              await github.rest.issues.removeLabel({
                owner,
                repo,
                issue_number: prNumber,
                name: 'max-iterations-reached'
              });
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
            }

            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: prNumber,
              labels: ['under-review']
            });

      - name: Ask CodeRabbit for review
        if: steps.pr.outputs.should_run == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
        env:
          REVIEW_AUTOMATION_TOKEN: ${{ secrets.REVIEW_AUTOMATION_TOKEN }}
        script: |
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const prNumber = Number.parseInt(
            '${{ steps.pr.outputs.pr_number }}',
            10
          );
          const automationToken = process.env.REVIEW_AUTOMATION_TOKEN;

          const postComment = async () => {
            if (!automationToken) {
              core.warning(
                'REVIEW_AUTOMATION_TOKEN missing. Falling back to GITHUB_TOKEN.'
              );
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: '@coderabbitai review'
              });
              return;
            }

            await github.request(
              'POST /repos/{owner}/{repo}/issues/{issue_number}/comments',
              {
                owner,
                repo,
                issue_number: prNumber,
                body: '@coderabbitai review',
                headers: {
                  authorization: `token ${automationToken}`
                }
              }
            );
          };

          await postComment();

      - name: Ask Codex for review
        if: steps.pr.outputs.should_run == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
        env:
          REVIEW_AUTOMATION_TOKEN: ${{ secrets.REVIEW_AUTOMATION_TOKEN }}
        script: |
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const prNumber = Number.parseInt(
            '${{ steps.pr.outputs.pr_number }}',
            10
          );
          const automationToken = process.env.REVIEW_AUTOMATION_TOKEN;

          const postComment = async () => {
            if (!automationToken) {
              core.warning(
                'REVIEW_AUTOMATION_TOKEN missing. Falling back to GITHUB_TOKEN.'
              );
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: '@codex review'
              });
              return;
            }

            await github.request(
              'POST /repos/{owner}/{repo}/issues/{issue_number}/comments',
              {
                owner,
                repo,
                issue_number: prNumber,
                body: '@codex review',
                headers: {
                  authorization: `token ${automationToken}`
                }
              }
            );
          };

          await postComment();
